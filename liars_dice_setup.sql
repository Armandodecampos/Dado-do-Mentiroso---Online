-- APAGA AS TABELAS E FUNÇÕES ANTIGAS PARA UMA REINSTALAÇÃO LIMPA
-- O uso de 'CASCADE' remove objetos dependentes (como políticas de RLS e chaves estrangeiras)
DROP TABLE IF EXISTS public.game_players CASCADE;
DROP TABLE IF EXISTS public.game_rooms CASCADE;
DROP FUNCTION IF EXISTS public.is_player_in_room(p_room_id BIGINT);
DROP FUNCTION IF EXISTS public.create_new_game_room(p_room_code TEXT);

-- Tabela para gerenciar as salas de jogo do Dado do Mentiroso
CREATE TABLE game_rooms (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    room_code TEXT NOT NULL UNIQUE,
    game_state TEXT NOT NULL DEFAULT 'lobby', -- 'lobby', 'in_progress', 'finished'
    current_turn_player_id UUID REFERENCES auth.users(id),
    last_bid_quantity INT,
    last_bid_face INT,
    last_bidder_id UUID REFERENCES auth.users(id),
    challenger_id UUID REFERENCES auth.users(id),
    round_history JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    host_id UUID NOT NULL REFERENCES auth.users(id),
    turn_expires_at TIMESTAMPTZ
);

-- Tabela para gerenciar os jogadores dentro de cada sala
CREATE TABLE game_players (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    room_id BIGINT NOT NULL REFERENCES game_rooms(id) ON DELETE CASCADE,
    player_id UUID NOT NULL REFERENCES auth.users(id),
    dice_count INT NOT NULL DEFAULT 5,
    dice_roll INT[], -- Array de inteiros para armazenar os resultados dos dados
    turn_order INT,
    UNIQUE(room_id, player_id)
);

-- Habilitar Segurança em Nível de Linha (RLS)
ALTER TABLE game_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE game_players ENABLE ROW LEVEL SECURITY;

-- Função para verificar se o usuário atual está em uma determinada sala.
-- SECURITY DEFINER é a chave aqui: executa com os privilégios do proprietário da função,
-- ignorando a RLS da tabela game_players e evitando a recursão.
CREATE OR REPLACE FUNCTION is_player_in_room(p_room_id BIGINT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM game_players
    WHERE room_id = p_room_id AND player_id = auth.uid()
  );
END;
$$;

-- Políticas de RLS para game_rooms
-- Permite que qualquer usuário autenticado crie uma sala.
CREATE POLICY "Allow authenticated users to create rooms"
ON game_rooms FOR INSERT
WITH CHECK (auth.uid() = host_id);

-- Permite que jogadores na sala leiam as informações da sala.
CREATE POLICY "Allow players in the room to read room data"
ON game_rooms FOR SELECT
USING (id IN (SELECT room_id FROM game_players WHERE player_id = auth.uid()));

-- Permite que qualquer utilizador autenticado veja as salas que estão no lobby.
CREATE POLICY "Allow authenticated users to see lobbies"
ON game_rooms FOR SELECT
USING (game_state = 'lobby' AND auth.role() = 'authenticated');

-- Permite que o anfitrião ou o jogador do turno atual atualize a sala.
CREATE POLICY "Allow host or current player to update room"
ON game_rooms FOR UPDATE
USING (
    auth.uid() = host_id OR
    auth.uid() = current_turn_player_id
);


-- Políticas de RLS para game_players
-- Permite que um usuário entre em uma sala (insira a si mesmo na tabela de jogadores).
CREATE POLICY "Allow users to join a room"
ON game_players FOR INSERT
WITH CHECK (auth.uid() = player_id);

-- Permite que um jogador leia seus próprios dados completos, incluindo a rolagem dos dados.
CREATE POLICY "Allow player to read their own data"
ON game_players FOR SELECT
USING (auth.uid() = player_id);

-- Permite que jogadores na mesma sala vejam os dados de outros jogadores (exceto a rolagem dos dados).
-- Permite que jogadores na mesma sala vejam os dados públicos de outros jogadores.
-- A lógica é: "Um usuário pode ver uma linha em game_players se existir outra linha na mesma sala que pertença a ele."
-- A lógica é: "Um usuário pode ver uma linha em game_players se a função is_player_in_room retornar verdadeiro para o room_id dessa linha."
CREATE POLICY "Allow players to see co-players' public data"
ON game_players FOR SELECT
USING (is_player_in_room(room_id));

-- Permite que um jogador atualize seus próprios dados (por exemplo, ao perder um dado).
CREATE POLICY "Allow player to update their own data"
ON game_players FOR UPDATE
USING (auth.uid() = player_id);

-- Permite que um jogador saia de uma sala.
CREATE POLICY "Allow player to leave a room"
ON game_players FOR DELETE
USING (auth.uid() = player_id);

-- Função RPC para criar uma sala de jogo e adicionar o anfitrião como jogador
-- Esta abordagem é mais segura e contorna problemas de RLS com múltiplas inserções.
CREATE OR REPLACE FUNCTION create_new_game_room(p_room_code TEXT)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_room game_rooms;
  host_id UUID := auth.uid();
BEGIN
  -- Insere a nova sala de jogo
  INSERT INTO public.game_rooms (room_code, host_id)
  VALUES (p_room_code, host_id)
  RETURNING * INTO new_room;

  -- Adiciona o anfitrião como o primeiro jogador
  INSERT INTO public.game_players (room_id, player_id)
  VALUES (new_room.id, host_id);

  -- Retorna os detalhes da sala criada como JSON
  RETURN json_build_object('id', new_room.id, 'room_code', new_room.room_code);
END;
$$;
