-- 1. TABELA DE PERFIS DE UTILIZADOR (PROFILES)
-- Esta tabela irá armazenar dados públicos que não devem estar na tabela `auth.users`.
-- A ligação é feita através do ID do utilizador.

CREATE TABLE public.profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  updated_at TIMESTAMPTZ,
  username TEXT UNIQUE,
  full_name TEXT,
  avatar_url TEXT,
  website TEXT,

  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- Comentários sobre a tabela de perfis:
-- id: Chave primária e estrangeira que aponta para auth.users.id. Garante que cada utilizador só pode ter um perfil.
-- ON DELETE CASCADE: Se um utilizador for apagado do sistema de autenticação, o seu perfil será apagado automaticamente.
-- UNIQUE: Garante que cada `username` seja único na plataforma.
-- CHECK: Uma restrição simples para garantir que o `username` tenha pelo menos 3 caracteres.


-- 2. ATIVAR A SEGURANÇA A NÍVEL DE LINHA (ROW-LEVEL SECURITY - RLS)
-- Esta é a parte mais CRÍTICA da segurança na Supabase.
-- Por defeito, RLS está desativada. Sem ela, qualquer pessoa com a chave de API `anon` pode ler, alterar e apagar os seus dados.

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Agora, criamos as políticas de segurança (POLICIES) para a tabela `profiles`.
-- Políticas definem QUEM pode fazer o QUÊ.

CREATE POLICY "Perfis públicos são visíveis para todos."
  ON public.profiles FOR SELECT
  USING ( true );

CREATE POLICY "Utilizadores podem criar o seu próprio perfil."
  ON public.profiles FOR INSERT
  WITH CHECK ( auth.uid() = id );

CREATE POLICY "Utilizadores podem atualizar o seu próprio perfil."
  ON public.profiles FOR UPDATE
  USING ( auth.uid() = id );

CREATE POLICY "Utilizadores podem apagar o seu próprio perfil."
  ON public.profiles FOR DELETE
  USING ( auth.uid() = id );

-- `auth.uid()` é uma função da Supabase que devolve o ID do utilizador autenticado que está a fazer o pedido.
-- É assim que garantimos que um utilizador só pode modificar os seus próprios dados.


-- 3. FUNÇÃO AUXILIAR PARA ATUALIZAR `updated_at` AUTOMATICAMENTE
-- Esta função (trigger) atualiza o campo `updated_at` sempre que uma linha na tabela `profiles` é alterada.

CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_profile_updated
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();


-- 4. TABELA DE EXEMPLO: POSTS (ex: para um blog ou rede social)
-- Para demonstrar como criar tabelas que se relacionam com os utilizadores.

CREATE TABLE public.posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ativar RLS para a tabela de posts também!
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

-- Políticas de segurança para a tabela `posts`:

CREATE POLICY "Posts são visíveis para todos."
  ON public.posts FOR SELECT
  USING ( true );

CREATE POLICY "Utilizadores autenticados podem criar posts."
  ON public.posts FOR INSERT
  WITH CHECK ( auth.role() = 'authenticated' AND auth.uid() = user_id );

CREATE POLICY "Utilizadores podem atualizar os seus próprios posts."
  ON public.posts FOR UPDATE
  USING ( auth.uid() = user_id );

CREATE POLICY "Utilizadores podem apagar os seus próprios posts."
  ON public.posts FOR DELETE
  USING ( auth.uid() = user_id );
